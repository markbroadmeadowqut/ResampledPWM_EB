/*
 * CMPA_calc.c
 *
 *  Created on: 16Jan.,2017
 *      Author: Edward
 */

interrupt void isr_CMPA_calc(void);


void initCMPAcalc() {
	EALLOW;
	PieVectTable.ADCINT1 = &isr_CMPA_calc;
	EDIS;

	PieCtrlRegs.PIEIER1.bit.INTx1 = 1;     // Enable PIE Group 1, INT1, ADCINT1
	IER |= M_INT1;
}




#pragma CODE_SECTION(isr_CMPA_calc, "ramfuncs");
interrupt void isr_CMPA_calc(void)
{
	Uint16 swCTRDIR;
	Uint16 swTBCTR;
	float32 calc1;
	float32 ti;
	Uint16 CMPA_value;

	//CpuTimer0.InterruptCount++;

	swTBCTR = EPwm1Regs.TBCTR;   			// Sample EPwm1 counter (Is this the correct way to read from address 0x0004??)
	swCTRDIR = EPwm1Regs.TBSTS.bit.CTRDIR;

	//DEBUG
	//GpioDataRegs.GPASET.bit.GPIO2 = 1;

	// Update CMPA register (and perform FOH calcs in the same line; hopefully it is faster to do it this way?)
	if(swCTRDIR) {
		calc1=((newSample-prevSample)*FOH_SCALE3)-FOH_SCALE4;
		ti=(swTBCTR-newSample)/calc1;
		//CMPA_value=floor((swTBCTR+(FOH_SCALE4*ti))+0.5);
		CMPA_value=swTBCTR+(FOH_SCALE4*ti);
		EPwm1Regs.CMPA.half.CMPA=CMPA_value;
		//DEBUG
		//GpioDataRegs.GPACLEAR.bit.GPIO2 = 1;
		if(CMPA_value<(swTBCTR+300)) {
			EALLOW;
			EPwm1Regs.AQSFRC.bit.ACTSFA = 1;	// Set output low on software force
			EDIS;
			EPwm1Regs.AQSFRC.bit.OTSFA = 1;
		}
	} else {
		calc1=((newSample-prevSample)*FOH_SCALE3)+FOH_SCALE4;
		ti=(swTBCTR-newSample)/calc1;
		CMPA_value=swTBCTR-(FOH_SCALE4*ti);
		EPwm1Regs.CMPA.half.CMPA=CMPA_value;
		//DEBUG
		//GpioDataRegs.GPACLEAR.bit.GPIO2 = 1;
		if(CMPA_value>(swTBCTR-300)) {
			EALLOW;
			EPwm1Regs.AQSFRC.bit.ACTSFA = 0;	// Set output high on software force
			EDIS;
			EPwm1Regs.AQSFRC.bit.OTSFA = 1;
		}
	}


	// DEBUG
	//EPwm1Regs.CMPA.half.CMPA=newSample;


	prevSample = newSample;       // Sample the modulating waveform at this point in the interrupt so that the write to CMPA happens sooner
	newSample = serviceDDS();	// Precompute sample for the next triggering of this interrupt
	// Should make sure that this ISR gets first priority if there are any other ISRs that might be called at the same time or before it.

	// Acknowledge this interrupt to receive more interrupts from group 1
	PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}
