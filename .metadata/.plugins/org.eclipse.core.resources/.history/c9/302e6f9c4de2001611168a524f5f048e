/*
 * pwm.c
 *
 *  Created on: 05/08/2016
 *      Author: broadmea
 */
#include "DSP28x_Project.h"
#include "config.h"

void initPWM() {
	EALLOW;	// PWM control registers are protected

	EPwm1Regs.TBPRD = SWTBPRD; // fc = 1/(2*4095/TBCLK) = 1/(2*4095/60000000) = 7.327kHz
	EPwm1Regs.TBPHS.all = 0; // Set Phase register for first module to zero; other two modules are phase displaced wrt this one
	EPwm1Regs.TBCTL.bit.CTRMODE = TB_FREEZE; // Make sure the counter is not counting yet when we are initialising EPwm1
	EPwm1Regs.TBCTL.bit.PHSDIR = 1; // After the sync event, ePWM1 will count up from phase 0
	EPwm1Regs.TBCTL.bit.PHSEN = TB_ENABLE; // Phase loading enabled
	EPwm1Regs.TBCTL.bit.PRDLD = TB_IMMEDIATE; // Load the TBPRD register immediately without using a shadow register
	EPwm1Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_DISABLE; // Disable EPwmxSYNCO signal
	EPwm1Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1; // TBCLK = SYSCLKOUT
	EPwm1Regs.TBCTL.bit.CLKDIV = TB_DIV1; // TBCLK = SYSCLKOUT
	EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_IMMEDIATE; // load CMPA immediately
	EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_IMMEDIATE; 
	EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // Don't care about this load functionality as we are using immediate load mode
	EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO;
	EPwm1Regs.AQCTLA.bit.CAU = AQ_CLEAR; // I want my PWM signal to be CLEARED to low when the carrier is increasing and the modulating signal falls below it...
	EPwm1Regs.AQCTLA.bit.CAD = AQ_SET; // ...and to be SET to high when the carrier is decreasing and the modulating signal rises above it.
	EPwm1Regs.AQSFRC.bit.ACTSFA = 1;	// Set output low on software force

	EPwm2Regs.TBPRD = SWTBPRD;
	EPwm2Regs.TBPHS.all = SWTBPHS23;
	EPwm2Regs.TBCTL.bit.CTRMODE = TB_FREEZE;
	EPwm2Regs.TBCTL.bit.PHSDIR = 1; // After the sync event, ePWM2 will count up from phase SWTBPHS23
	EPwm2Regs.TBCTL.bit.PHSEN = TB_ENABLE;
	EPwm2Regs.TBCTL.bit.PRDLD = TB_IMMEDIATE;
	EPwm2Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_DISABLE;
	EPwm2Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;
	EPwm2Regs.TBCTL.bit.CLKDIV = TB_DIV1;
	EPwm2Regs.CMPCTL.bit.SHDWAMODE = CC_IMMEDIATE;
	EPwm2Regs.CMPCTL.bit.SHDWBMODE = CC_IMMEDIATE;
	EPwm2Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO;
	EPwm2Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO;
	EPwm2Regs.AQCTLA.bit.CAU = AQ_CLEAR;
	EPwm2Regs.AQCTLA.bit.CAD = AQ_SET;
	EPwm2Regs.AQSFRC.bit.ACTSFA = 1;

	EPwm3Regs.TBPRD = SWTBPRD;
	EPwm3Regs.TBPHS.all = SWTBPHS23;
	EPwm3Regs.TBCTL.bit.CTRMODE = TB_FREEZE;
	EPwm3Regs.TBCTL.bit.PHSDIR = 0; // After the sync event, ePWM3 will count down from phase SWTBPHS23
	EPwm3Regs.TBCTL.bit.PHSEN = TB_ENABLE;
	EPwm3Regs.TBCTL.bit.PRDLD = TB_IMMEDIATE;
	EPwm3Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_DISABLE;
	EPwm3Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;
	EPwm3Regs.TBCTL.bit.CLKDIV = TB_DIV1;
	EPwm3Regs.CMPCTL.bit.SHDWAMODE = CC_IMMEDIATE;
	EPwm3Regs.CMPCTL.bit.SHDWBMODE = CC_IMMEDIATE;
	EPwm3Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO;
	EPwm3Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO;
	EPwm3Regs.AQCTLA.bit.CAU = AQ_CLEAR;
	EPwm3Regs.AQCTLA.bit.CAD = AQ_SET;
	EPwm3Regs.AQSFRC.bit.ACTSFA = 1;

	
	
	
	GpioCtrlRegs.GPAMUX1.bit.GPIO0 = 01;	// EPWM1A on GPIO0
	GpioCtrlRegs.GPADIR.bit.GPIO0 = 1;	// Output on GPIO0
	GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 01;	// EPWM1B on GPIO1
	GpioCtrlRegs.GPADIR.bit.GPIO1 = 1;	// Output on GPIO1
	GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 01;	// EPWM2A on GPIO2
	GpioCtrlRegs.GPADIR.bit.GPIO2 = 1;	// Output on GPIO2
	GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 01;	// EPWM2B on GPIO3
	GpioCtrlRegs.GPADIR.bit.GPIO3 = 1;	// Output on GPIO3
	GpioCtrlRegs.GPAMUX1.bit.GPIO4 = 01;	// EPWM3A on GPIO2
	GpioCtrlRegs.GPADIR.bit.GPIO4 = 1;	// Output on GPIO4
	GpioCtrlRegs.GPAMUX1.bit.GPIO5 = 01;	// EPWM3B on GPIO3
	GpioCtrlRegs.GPADIR.bit.GPIO5 = 1;	// Output on GPIO5


	// DEBUG
	//EPwm1Regs.CMPA.half.CMPA = 31250;	// 50% duty


	EDIS;
}

void pwmStart() {
	EALLOW;
	EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN;
	EPwm2Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN;
	EPwm3Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN;
	// DEBUG
	//EPwm1Regs.CMPA.half.CMPA=4000;
	EDIS;
}

void pwmStop() {
	EALLOW;
	EPwm1Regs.TBCTL.bit.CTRMODE = TB_FREEZE;  // How to reset GPIO???
	EPwm1Regs.TBCTR = 0;	// Reset counter
	EPwm1Regs.AQSFRC.bit.OTSFA = 1;
	EDIS;
}
