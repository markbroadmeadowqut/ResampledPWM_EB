/*
 * timer.c
 *
 *  Created on: 22/05/2015
 *      Author: broadmea
 */
#include "DSP28x_Project.h"
#include "config.h"

volatile Uint32 newSample = 0;
volatile Uint32 prevSample = 0;

interrupt void isr_cpu_timer0(void);

void initADC() {

	EALLOW;
	SysCtrlRegs.PCLKCR0.bit.ADCENCLK = 1; // enable the ADC clock; must be done before writing to any of the ADC registers

	AdcRegs.ADCCTL1.bit.ADCREFSEL = 0; // use the internal reference so that RTDS output values need to be between 0 and 3.3V
	// Note that Vreflo is tied to ground on the C2000 Launchpad

	// Are we skipping the boot process? Do we need to call the Device_cal() function?

	// IS THERE A WAY TO ENABLE ALL THREE OF THESE POWER UP BITS AT ONCE??
	AdcRegs.ADCCTL1.bit.ADCPWDN = 1; // Power up the ADC
	AdcRegs.ADCCTL1.bit.ADCBGPWD = 1; // Power up the band-gap circuit (the circuit we use for the 3.3V internal reference??)
	AdcRegs.ADCCTL1.bit.ADCREFPWD = 1; // Power up the Reference Buffer circuitry of the ADC (not sure what this one actually does)...
	AdcRegs.ADCCTL1.bit.ADCENABLE = 1; // enable the ADC
	AdcRegs.ADCCTL1.bit.INTPULSEPOS = 1; // generate the FOH_interrupt pulse 1 cycle before latching conversion result to the result register (how do we know this won't be too early??)
	AdcRegs.ADCCTL1.bit.VREFLOCONV = 0; // disable ADCINB5 connection to VREFLO
	AdcRegs.ADCCTL1.bit.TEMPCONV = 0; // disable ADCINA5 connection to temperature sensor

	AdcRegs.ADCCTL2.bit.ADCNONOVERLAP = 1; // Overlap of sample is not allowed; I'm assuming this means that the sampler that writes to the ADC result register will not do so until the conversion process is finished???
	AdcRegs.ADCCTL2.bit.CLKDIV2EN = 0; // not sure why you would want to divide the ADC clock by 2...

	AdcRegs.INTSEL1N2.bit.INT1CONT = 1; // I will use ADCINT1 to trigger the FOH-ISR and I want this ISR to be called every time an EOC happens on ADCINA0...(In other words I don't want to use the ADCINTFLGCLR or ADCINTOVFCLR registers)
	AdcRegs.INTSEL1N2.bit.INT1E = 1; // Enable ADCINT1 (I am pretty sure all of the others are disabled by default)
	AdcRegs.INTSEL1N2.bit.INT1SEL = 0; // Select EOC0 as the trigger for ADCINT1

	AdcRegs.SOCPRICTL.bit.SOCPRIORITY = 0x10; // Set SOC priority so that all SOCs are in high priority mode; SOC0 has the smallest number and will therefore always be executed first if any other SOC is triggered accidently

	AdcRegs.ADCSAMPLEMODE.all = 0; // Set all SOCs to Single Sample Mode
	AdcRegs.ADCINTSOCSEL1.all = 0; // Don't allow any ADCINTs to trigger any SOCs
	AdcRegs.ADCINTSOCSEL2.all = 0;





	EDIS;




	InitCpuTimers();
	ConfigCpuTimer(&CpuTimer0, 150, 80); 			// Set clock to 150MHz, timer period to 25us period so that fs=10kHz (would be good to make this automatically updated with fs in config.h)
	CpuTimer0Regs.TCR.all = 0x4001; 				// Start CPU Timer0. Use write-only instruction to set TSS bit = 0

	//DEBUG
	GpioDataRegs.GPACLEAR.bit.GPIO2 = 1;
	EALLOW;
	GpioCtrlRegs.GPADIR.bit.GPIO2 = 1;				// Set GPIO2 as output
	EDIS;

	EALLOW;
	PieVectTable.TINT0 = &isr_cpu_timer0;
	EDIS;

	PieCtrlRegs.PIEIER1.bit.INTx7 = 1;     // PIE Group 1, INT7, TINT0

	IER |= M_INT1;
}

#pragma CODE_SECTION(isr_cpu_timer0, "ramfuncs");
interrupt void isr_cpu_timer0(void)
{
	char swCTRDIR;
	Uint16 swTBCTR;
	Uint32 calc1;
	Uint32 ti;
	Uint16 CMPA_value;

	//CpuTimer0.InterruptCount++;
	
	swTBCTR = EPwm1Regs.TBCTR;   			// Sample EPwm1 counter (Is this the correct way to read from address 0x0004??)
	swCTRDIR = EPwm1Regs.TBSTS.bit.CTRDIR;
	
	//DEBUG
	//GpioDataRegs.GPASET.bit.GPIO2 = 1;

	// Update CMPA register (and perform FOH calcs in the same line; hopefully it is faster to do it this way?)
	if(swCTRDIR) {
		calc1=((newSample-prevSample)*FOH_SCALE3)-FOH_SCALE4; // may perhaps migrate this into the RTDS
		ti=(swTBCTR-newSample)/calc1;
		//CMPA_value=floor((swTBCTR+(FOH_SCALE4*ti))+0.5);
		CMPA_value=swTBCTR+(FOH_SCALE4*ti);
		EPwm1Regs.CMPA.half.CMPA=CMPA_value;
		//DEBUG
		//GpioDataRegs.GPACLEAR.bit.GPIO2 = 1;
		if(CMPA_value<(swTBCTR+300)) {
			EALLOW;
			EPwm1Regs.AQSFRC.bit.ACTSFA = 1;	// Set output low on software force
			EDIS;
			EPwm1Regs.AQSFRC.bit.OTSFA = 1;
		}
	} else {
		calc1=((newSample-prevSample)*FOH_SCALE3)+FOH_SCALE4;
		ti=(swTBCTR-newSample)/calc1;
		CMPA_value=swTBCTR-(FOH_SCALE4*ti);
		EPwm1Regs.CMPA.half.CMPA=CMPA_value;
		//DEBUG
		//GpioDataRegs.GPACLEAR.bit.GPIO2 = 1;
		if(CMPA_value>(swTBCTR-300)) {
			EALLOW;
			EPwm1Regs.AQSFRC.bit.ACTSFA = 0;	// Set output high on software force
			EDIS;
			EPwm1Regs.AQSFRC.bit.OTSFA = 1;
		}
	}
		

	// DEBUG
	//EPwm1Regs.CMPA.half.CMPA=newSample;


	prevSample = newSample;       // Sample the modulating waveform at this point in the interrupt so that the write to CMPA happens sooner
	newSample = 30000;	// Precompute sample for the next triggering of this interrupt
	// Should make sure that this ISR gets first priority if there are any other ISRs that might be called at the same time or before it.
			
	// Acknowledge this interrupt to receive more interrupts from group 1
	PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}
